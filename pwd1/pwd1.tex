\documentclass{article}
\setlength{\headheight}{8pt}

\usepackage[a4paper, margin=0.3in]{geometry}
\usepackage{lmodern}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{hyperref}
\usepackage[shortlabels]{enumitem}
\usepackage{physics}
\usepackage{multicol}

% Definicje środowisk do twierdzeń, lematów, dowodów itp.
\newtheorem{theorem}{Twierdzenie}[section]
\newtheorem{lemma}[theorem]{Lemat}
\newtheorem{corollary}[theorem]{Wniosek}
\newtheorem{proposition}[theorem]{Stwierdzenie}
\theoremstyle{definition}
\newtheorem{definition}{Definicja}[section]
\theoremstyle{remark}
\newtheorem*{remark}{Uwaga}
\newtheorem*{example}{Przykład}
\newtheorem*{property}{Własność}

\title{Praca domowa 1}
\author{Marcin Szopa}
\date{\today}

% Remove padding at the top of subsections
\usepackage{titlesec}
\titlespacing*{\subsection}{0pt}{*0}{*0}

\begin{document}

\maketitle

W całej pracy przyjmujemy, że pracujemy na językach nad alfabetem (skończonym) \(\Sigma\), tz. w \( \Sigma^* \).

\(\mathcal{A}\) to klasa automatów rozpoznających te języki.

\section{a}

\subsection{Zdefiniumy przekształcenie:}

\(F: \mathcal{A} \to \mathcal{A}\), które dla automatu \(\left(\Sigma, Q, I, F, \sigma\right)\) zwraca automat \(\left(\Sigma, Q, I, F, \sigma'\right)\), gdzie

\begin{align*}
\sigma' = \sigma \cup \bigcup_{l \in \Sigma} \left\{ \left< p, l, q \right> \mid \exists_{\epsilon \neq a \in \Sigma}{\left< p, a, q \right> \in \sigma} \right\}
\end{align*}

Inaczej, po prostu każda niepusta krawędź będzie akceptować dowolną literę. 

Zauważmy, że powstały automat jest skończony, bo dokładamy conajwyżej \(\abs{\Sigma} \cdot \abs{Q}^2\) krawędzi. Zatem rozpoznaje on język regularny.

\begin{lemma}
    \(w \in L(F(A)) \iff \exists_{v \in L(A)} \abs{w}=\abs{v}\)
\end{lemma}
\begin{proof}

`\(\rightarrow\)` \\
Niech \(w \in L(F(A))\). Wtedy istnieje ścieżka w \(F(A)\) akceptująca \(w\). Zauważmy, że \(\forall_{\left< p, a, q \right>}\) z tego biegu \( \exists_{b \neq \epsilon} \left< p, b, q \right> \in \sigma\). Zatem moglibyśmy zamienić litery z aktualnej ścieżki na litery na odpowiadających krawędziach z \(A\) i otrzymalibyśmy bieg akceptujący słowo \(v\). Nie zmieniła się liczba przejść, a każda zamiana z litery \(\neq \epsilon\) była też na literę \(\neq \epsilon\). Stąd \(\abs{v}=\abs{w}.\) \(\blacksquare\)

`\(\leftarrow\)` \\
Niech \(v \in L(A)\). Skoro \(F\) jedynie dodało przejścia między stanami, to \(v \in L(F(A))\), bo \(\sigma \subseteq \sigma'\). \(\blacksquare\)

\end{proof}

\subsection{Rozważmy założenia języka:}

\begin{align*}
    \exists_{ a_i \in L(K), \ b_i \in L(L)} { a_i = b_i = c_i }\iff c_i \in L(K) \cap L(L)
\end{align*}

\begin{align*}
\exists_{ a_i \in L(K), \ b_i \in L(L)} { c_i \in \left\{ a_i, b_i \right\} \land \abs{a_i}=\abs{b_i}=\abs{c_i} }
\end{align*}

\begin{align*}
\iff
\left( c_i \in L(K) \land \exists_{ b_i \in L(L) }{ \abs{c_i} = \abs{b_i} } \right) \lor \left( c_i \in L(L) \land \exists_{ a_i \in L(K) }{ \abs{c_i} = \abs{a_i} } \right)
\end{align*}

\begin{align*}
    \iff
    \left( c_i \in L(K) \land c_i \in L(F(L)) \right) \lor \left( c_i \in L(L) \land c_i \in L(F(K)) \right)
\end{align*}

\begin{align*}
    \iff
    c_i \in \left( L(K) \cap L(F(L)) \cup L(L) \cap L(F(K)) \right)
\end{align*}

\subsection{Teza}

Niech \( E := \left( L(K) \cap L(F(L)) \cup L(L) \cap L(F(K)) \right) \) oraz \( G := L(K) \cap L(L) \).
Oba języki są regularne, bo powstały poprzez operacje zachowujące regularność na językach regularnych.

\begin{theorem}
    \begin{align*}
        w \in L(K \# L) \iff w \in \left( G \cdot E \right)^* \cdot \left( G + \epsilon \right)
    \end{align*}
\end{theorem}

\begin{proof}

`\(\rightarrow\)`

Niech \(w \in L(K \# L)\). Z definicji istnieją \(a_1, \ldots , a_n \in L(K), b_1, \ldots b_n \in L(L), c_1, \ldots c_n\), że \(w = c_1 \cdot \ldots \cdot c_n\) i \(\ldots\)
Zauważmy, że skoro \(a_{2i}=b_{2i}=c_{2i}\), to \(c_{2i} \in L(K) \cap L(L)\). 
Więc \(c_{2i} \in G\).
Skoro \(c_{2i+1} \in \left\{ a_{2i+1}, b_{2i+1} \right\}\), to \(c_{2i+1} \in E\).
Stąd \(w\) ma strukturę \(G \cdot E \cdot G \ldots \cdot \left( E + \epsilon \right)\).
Zatem \(w \in \left( G \cdot E \right)^* \cdot \left( G + \epsilon \right)\). 
\(\blacksquare\)

`\(\leftarrow\)`

Niech \(w \in \left( G \cdot E \right)^* \cdot \left( G + \epsilon \right)\). Zatem \(w\) ma strukturę \(G \cdot E \cdot G \cdot \ldots \cdot \left( E + \epsilon \right)\). 
Stąd istnieją \(c_1 \in G, c_2 \in E, c_3 \in G, \ldots c_n \in E \cup \left\{ \epsilon \right\}\), że \(w = c_1 \cdot \ldots \cdot c_n\).

Rozważmy \(c_i\), gdzie \(i < n\):

\begin{itemize}
    \item \(c_{2i+1} \in G\). \(c_{2i+1} \in L(K) \cap L(L) \iff c_{2i+1} \in L(K) \land c_{2i+1} \in L(L)\). Zatem istnieją \(a_{2i+1} \in L(K), b_{2i+1} \in L(L)\), że \(c_{2i+1} = a_{2i+1} = b_{2i+1} \implies \abs{c_{2i+1}} = \abs{a_{2i+1}} = \abs{b_{2i+1}}\).
    \item \(c_{2i} \in E\). \(c_{2i} \in \left( L(K) \cap L(F(L)) \cup L(L) \cap L(F(K)) \right) \iff c_{2i} \in L(K) \cap L(F(L)) \lor c_{2i} \in L(L) \cap L(F(K)) \iff \exists_{a_i \in L(K), b_i \in L(L)} c_{2i} \in \left\{ a_{2i}, b_{2i} \right\}\).
\end{itemize}

Jeśli \(c_n = \epsilon\), to możemy pominąć ostatnią literę i rozumowanie działa. W przeciwnym razie \(c_n \in G\), więc działa rozumowanie dla \(c_{2n+1}\).

\end{proof}

\end{document}