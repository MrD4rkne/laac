\documentclass{article}
\setlength{\headheight}{8pt}

\usepackage[a4paper, margin=0.3in]{geometry}
\usepackage{lmodern}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{hyperref}
\usepackage[shortlabels]{enumitem}
\usepackage{physics}
\usepackage{multicol}
\usepackage{titlesec}
\usepackage{tikz}
\usetikzlibrary{automata, positioning}

% Definicje środowisk do twierdzeń, lematów, dowodów itp.
\newtheorem{theorem}{Twierdzenie}[section]
\newtheorem{lemma}[theorem]{Lemat}
\newtheorem{corollary}[theorem]{Wniosek}
\newtheorem{proposition}[theorem]{Stwierdzenie}
\theoremstyle{definition}
\newtheorem{definition}{Definicja}[section]
\theoremstyle{remark}
\newtheorem{remark}{Uwaga}[section]
\newtheorem*{example}{Przykład}
\newtheorem*{property}{Własność}

\title{Praca domowa 2}
\author{Marcin Szopa 459531}
\date{\today}

% Remove padding at the top of subsections
\titlespacing*{\subsection}{0pt}{*0}{*0}

% Redefine section numbering to use letters
\renewcommand{\thesection}{\Alph{section}}

% Define a command for singleton sets
\newcommand{\singleton}[1]{\left\{ #1 \right\}}

\begin{document}

\maketitle

\section{niepisząca maszyna Turinga z 1 taśmą roboczą}

Weźmy taką maszynę \(M\).

Zauważmy, że zgodnie z definicją \(P\) jest puste, gdyż mamy tylko 1 taśmę roboczą.

Stąd pomińmy pusty zbiór w funkcji przejścia, gdyż nic on nie wnosi. Tz. w dowolnej konfiguracji ten "warunek" jest spełniony: \(\delta \subseteq, Q \times A \times Q \times \left\{ \circlearrowright,  \rightarrow  \right\} \times \left\{ \leftarrow, \circlearrowright,  \rightarrow  \right\}^k\).

Pokażę, że taśma robocza jest bezużyteczna. Wynika to z faktu, że możemy się po niej w sposób nieograniczony poruszać, jednakże nic z niej odczytywać. Stąd tak naprawdę \(M\) to automat.

Zdefiniujmy \(M_A = \left<\Sigma_A, Q_A, I_A, F_A, \delta_A \right>\):
\begin{itemize}
\item \(\Sigma_A = \Sigma\)
\item \(Q_A = Q \times \Sigma \cup \{ \left< S, \epsilon \right> \} \)
\item \(I_A = \{ \left<q_M, x \right>: q_M \in I \land x \in \Sigma \}\)
\item \(F_A = F \times \Sigma\)
\item \(\delta_A\) jest zdefiniowane następująco:
\begin{itemize}
\item mapujemy \( \left<q, a, q', \rightarrow, \leftarrow / \circlearrowright / \rightarrow \right> \in \delta\) na \( \{ \left< \left<q,a\right>, a, \left<q',x\right> \right>: x \in \Sigma \} \),
czyli gdy maszyna widzi pod głowicą literę \(a\), jest w stanie \(q\) i przechodzi do stanu \(q'\) to w \(M_A\) będzie to wyglądać tak, że maszyna widzi literę \(a\), jest w stanie \(\left<q,a\right>\) i przechodzi do stanu \(\left<q',x\right>\), gdzie \(x\) jest dowolną literą z alfabetu (gdyż nie wiadomo co jest dalej). Jednak bieg akceptujący dalej z tego stnau będzie istniał wtw następną literą jest dane \(x\).

\item mapujemy \( \left<q, a, q', \circlearrowright, \leftarrow / \circlearrowright / \rightarrow \right> \in \delta\) na \( \{ \left< \left<q,a\right>, \epsilon, \left<q',a\right> \right>\} \), czyli gdy maszyna widzi pod głowicą literę \(a\), jest w stanie \(q\) i przechodzi do stanu \(q'\) bez zmiany głowicy to w \(M_A\) będzie to wyglądać tak, że maszyna widzi literę \(a\), jest w stanie \(\left<q,a\right>\) i przechodzi do stanu \(\left<q',a\right>\) nie wykorzystując litery.

\end{itemize}

\(\delta\) jest sumą zbiorów przejść z powyższych przypadków.

\begin{remark}\label{remark:transition}
    Zauważmy, że ze stanu \(\left<q,a\right>\) maszyna \(M_A\) może przejść do stanu \(\left<q',x\right>\) tylko wtedy,
    gdy wczyta literę \(a\) lub do stanu \(\left<q',a\right>\) bez wczytania litery.
\end{remark}

\end{itemize}

Pokażemy, że \(\mathcal{L}(M) = \mathcal{L}(M_A)\).

\begin{proof}
`\(\subseteq\)'

Niech \(w \in \mathcal{L}(M)\). Wtedy istnieje akceptujący bieg \(b\) maszyny \(M\) na słowie \(w\).
Zauważmy, że każdy bieg akceptujący maszyny \(M\) można odwzorować na bieg akceptujący maszyny \(M_A\):

Automat zgadnie początkowy stan \(\left<q_0,x \right>\) zgodnie z \(\ref{remark:transition}\).
Następnie będzie wczytywać litery z \(w\) i przechodzić do stanów \(\left<q,a\right>\) zgodnie z regułami przejść maszyny \(M\). W końcu, gdy maszyna \(M\) osiągnie stan akceptujący \(q_f\), maszyna \(M_A\) będzie w stanie \(\left<q_f,x\right>\), gdzie \(x\) jest dowolną literą z alfabetu. 
Ostatecznie maszyna \(M_A\) zaakceptuje słowo \(w\), gdyż będzie w stanie akceptującym \(\left<q_f,x\right>\).
Zatem \(w \in \mathcal{L}(M_A)\).
\end{proof}

\begin{proof}
`\(\supseteq\)'

Niech \(w \in \mathcal{L}(M_A)\). Wtedy istnieje akceptujący bieg \(b\) maszyny \(M_A\) na słowie \(w\).
Zauważmy, że każdy bieg akceptujący maszyny \(M_A\) można odwzorować na bieg akceptujący maszyny \(M\):

Na początku maszyna \(M_A\) jest w stanie \(q_0\), a głowicę ma nad pierwszą literą słowa \(w\).
Następnie będzie wczytywać litery z \(w\) i przechodzić do stanów \(\left<q,a\right>\) zgodnie ze swoją definicją.
\begin{itemize}
\item Jeśli przejście w \(b\) jest zdefiniowane jako \( \left< \left<q,a\right>, a, \left<q',x\right> \right> \),
 to maszyna \(M\) przechodzi do stanu \(q'\) wczytując literę \(a\) i przesuwajac głowicę w prawo.
\item Jeśli przejście w \(b\) jest zdefiniowane jako \( \left< \left<q,a\right>, \epsilon, \left<q',a\right> \right> \),
 to maszyna \(M\) przechodzi do stanu \(q'\) bez wczytywania litery i nie przesuwa głowicy.
\end{itemize}

W końcu, gdy maszyna \(M_A\) osiągnie stan akceptujący \(\left<q_f,x\right>\), maszyna \(M\) będzie w stanie \(q_f \in I\).
Zatem \(w \in \mathcal{L}(M)\).
\end{proof}

\section{niepisząca maszyna Turinga z 2 taśmami roboczymi}
Weźmy taką maszynę \(M\).

Zauważmy, że obecność 2 taśm roboczych pozwala nam na sprawdzenie, czy 
\( \#_{a}(\rightarrow) - \#_{a}(\leftarrow) = \#_{b}(\rightarrow) -  \#_{b}(\leftarrow) \) dla taśm \(a\) i \(b\).

\[ \#_{a}(\rightarrow) - \#_{a}(\leftarrow) = \#_{b}(\rightarrow) -  \#_{b}(\leftarrow) \iff  \#_{a}(\rightarrow) + \#_{b}(\leftarrow) = \#_{b}(\rightarrow) + \#_{a}(\leftarrow) \]

Czyli tak naprawdę możemy kodować informację o ruchach głowicy na taśmie \(a\) i taśmie \(b\) w jednym liczniku \(c\):
\begin{itemize}
\item \( \#_{a}(\rightarrow) + \#_{b}(\leftarrow) \) - liczba ruchów głowicy na taśmie \(a\) w prawo i liczba ruchów głowicy na taśmie \(b\) w lewo - \(c++\).
\item \( \#_{a}(\leftarrow) + \#_{b}(\rightarrow) \) - liczba ruchów głowicy na taśmie \(a\) w lewo i liczba ruchów głowicy na taśmie \(b\) w prawo - \(c--\).
\item jeśli głowice się nie ruszają, to \(c\) nie zmienia swojej wartości.
\item \(a == b \iff c == 0\).
\end{itemize}

Jednak naturalne dla języków bezkontekstowych jest to, że są rozpoznawane przez automaty ze stosem, a nie automaty z licznikiem.
Dlatego będziemy kodować wartość licznika \(c\) na stosie:
\begin{itemize}
\item \(c++\) - zdejmujemy ze stosu literę \(b\) (jeśli jest co zdejmować). Wpp dodajemy literę \(a\) na stos.
\item \(c--\) - zdejmujemy ze stosu literę \(a\) (jeśli jest co zdejmować). Wpp dodajemy literę \(b\) na stos.
\item jeśli licznik nie zmienia swojej wartości, to nie zmieniamy stosu (\(\text{pop}(\epsilon), \text{push}(\epsilon)\)).
\item \(c == 0 \iff \text{stos jest pusty}\).
\end{itemize}

Zdefiniujmy automat ze stosem \(M_S = \left<\Sigma_S, Q_S, q_{S_0}, F_S, s_0, \delta_S \right>\):
\begin{itemize}
\item \(\Sigma_S = \Sigma\)
\item \(Q_S = Q \times \Sigma \cup \{ \left< S, \epsilon, \epsilon \right> \} \)
\item \(q_{S_0} = \left< q_M, x, y \right>\), gdzie \(x\) i \(y\) są dowolnymi literami z alfabetu.
\item \(F_S = F \times \Sigma \times \Sigma\)
\item \(\delta_S\) jest zdefiniowane następująco:
\begin{itemize}
\item mapujemy \( \left<q, a, q', \rightarrow, \leftarrow / \circlearrowright / \rightarrow \right> \in \delta\) na \( \{ \left< \left<q,a,y\right>, a, \left<q',x,y\right> \right>: x,y \in \Sigma \} \),  
czyli gdy maszyna widzi pod głowicą literę \(a\), jest w stanie \(q\) i przechodzi do stanu \(q'\) to w \(M_S\) będzie to wyglądać tak, że maszyna widzi literę \(a\), jest w stanie \(\left<q,a,y\right>\) i przechodzi do stanu \(\left<q',x,y\right>\), gdzie \(x\) i \(y\) są dowolnymi literami z alfabetu (gdyż nie wiadomo co jest dalej). Jednak bieg akceptujący dalej z tego stanu będzie istniał wtw następną literą jest dane \(x\).

\item mapujemy \( \left<q, a, q', \circlearrowright, \leftarrow / \circlearrowright / \rightarrow \right> \in \delta\) na \( \{ \left< \left<q,a,y\right>, \epsilon, \left<q',a,y\right> \right>\} \), czyli gdy maszyna widzi pod głowicą literę \(a\), jest w stanie \(q\) i przechodzi do stanu \(q'\) bez zmiany głowicy to w \(M_S\) będzie to wyglądać tak, że maszyna widzi literę \(a\), jest w stanie \(\left<q,a,y\right>\) i przechodzi do stanu \(\left<q',a,y\right>\) nie wykorzystując litery.
\item mapujemy \( \left<q, a, q', \rightarrow, \leftarrow / \circlearrowright / \rightarrow \right> \in \delta\) na \( \{ \left< \left<q,a,y\right>, a, \left<q',x,y\right> \right>: x,y \in \Sigma \} \), czyli gdy maszyna widzi pod głowicą literę \(a\), jest w stanie \(q\) i przechodzi do stanu \(q'\) przesuwając głowicę w prawo to w \(M_S\) będzie to wyglądać tak, że maszyna widzi literę \(a\), jest w stanie \(\left<q,a,y\right>\) i przechodzi do stanu \(\left<q',x,y\right>\), gdzie \(x\) i \(y\) są dowolnymi literami z alfabetu (gdyż nie wiadomo co jest dalej). Jednak bieg akceptujący dalej z tego stanu będzie istniał wtw następną literą jest dane \(x\).
\item mapujemy \( \left<q, a, q', \circlearrowright, \leftarrow / \circlearrowright / \rightarrow \right> \in \delta\) na \( \{ \left< \left<q,a,y\right>, a, \left<q',x,y\right> \right>: x,y \in \Sigma \} \), czyli gdy maszyna widzi pod głowicą literę \(a\), jest w stanie \(q\) i przechodzi do stanu \(q'\) bez zmiany głowicy to w \(M_S\) będzie to wyglądać tak, że maszyna widzi literę \(a\), jest w stanie \(\left<q,a,y\right>\) i przechodzi do stanu \(\left<q',x,y\right>\), gdzie \(x\) i \(y\) są dowolnymi literami z alfabetu (gdyż nie wiadomo co jest dalej). Jednak bieg akceptujący dalej z tego stanu będzie istniał wtw następną literą jest dane \(x\).
\end{itemize}
\end{itemize}

\end{document}